\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\author{Friedrich Weber\\
\small fweber@posteo.de}
\title{Superinstructions for the SOMns interpreter}

\usetikzlibrary{trees}
\tikzstyle{every node}=[draw=black,thick,anchor=west]

\newcommand{\sinst}[1]{\textsf{#1}}

\begin{document}
	
\maketitle

My superinstruction project for the SOMns interpreter consists of two parts:
\begin{itemize}
	\item A dynamic analysis for automatically identifying promising candidates for superinstructions. The idea of the candidate detection heuristic is explained in Section~\ref{sec:heuristic}.
	\item Implementation of several candidates for superinstructions. A short description of the implemented candidates can be found in Section~\ref{sec:superinst}.
\end{itemize}

\section{Heuristic}\label{sec:heuristic}

The heuristic consists of two stages: The \emph{context collection} stage and the \emph{candidate detection} stage. They are explained separately in the following.

\subsection{Context Collection}

During execution of the program in question, the modified SOMns interpreter dynamically counts the number of activations for each AST node. In this, it also takes the Java type of the activation result into account. Consider, for example, the following code snippet:
\begin{verbatim}
value:: value + 1
\end{verbatim}
which will be parsed into an AST similar to the following:
\begin{verbatim}
LocalVariableWriteNode
  EagerBinaryPrimitiveNode
    LocalVariableReadNode
    IntegerLiteralNode
    AdditionPrim
\end{verbatim}
We now assume that the \textsf{value} slot stores a numeric value represented by a Java \textsf{Long} and consider a program run in which the \textsf{LocalVariableReadNode} is activated 100 times. During execution, the dynamic analysis records the fact that the \textsf{LocalVariableReadNode} has been activated 100 times, each time producing a \textsf{Long} value. This dynamic analysis is implemented in the \textsf{tools.dym.nodes.TypeCountingNode} and \textsf{tools.dym.profiles.TypeCounter} classes.

After execution, the analysis constructs a set of so-called \emph{activation contexts}. An activation context consists of two parts, a \emph{trace} and a \emph{type}, and is implemented in \textsf{tools.dym.superinstructions.ActivationContext}.

The \emph{type} denotes the Java type of the node activation result. A \emph{trace} is a sequence of strings and integers and has the general form
\begin{align*}
[ C_0, s_0, C_1, ..., s_{n - 1}, C_{n}]
\end{align*}
in which all $C_k$ are Java node class names and all $s_k$ are child slot indices. A trace represents the environment in which a node was activated. The rightmost node class name (i.e. $C_n$) is the class name of the activated node. Its preceding node class name $C_{n-1}$ denotes its parent AST node and $s_{n-1}$ denotes the child slot in which the activated node is located. This construction is continued extended up to a predefined length.

Instances of \textsf{EagerPrimitive} nodes are handled separately: Here, the heuristic constructs an artificial node class from the operation name, e.g.\ an \textsf{EagerBinaryPrimitiveNode} node with an addition primitive is denoted as \textsf{PrimitiveOperation:+}.

In my heuristic, I construct traces up to $n=2$. Thus, for the \textsf{LocalVariableReadNode} in the exemplary AST, the following activation contexts are constructed:

\begin{verbatim}
ActivationContext(type=Long, trace=[LocalVariableReadNode])
ActivationContext(type=Long, trace=[PrimitiveOperation:+, 0,
                                    LocalVariableReadNode])
ActivationContext(type=Long, trace=[LocalVariableWriteNode, 0,
                                    PrimitiveOperation:+, 0,
                                    LocalVariableReadNode])
\end{verbatim}

Each activation context is annotated with its number of activations. In the example, all three activation contexts are annotated with $100$ (because the corresponding \textsf{LocalVariableReadNode} was activated 100 times). 

The result of the context collection stage is a map mapping activation contexts to activation counts. The context collector is implemented in the Java class \textsf{tools.dym.superinstructions.ContextCollector}.

\subsection{Candidate Detection}

Based on this map, the heuristic aims to detect superinstruction candidates. A superinstruction candidate is represented by an AST subtree containing a number of nodes which could be replaced by just one node, constituting a superinstruction.

First, the heuristic extracts all activation contexts with traces of length $n = 2$, sorts them by their activation count in descending order and extracts a predefined number of contexts with the highest activation counts (currently 100).

Consequently, these contexts are all of the form

\begin{quotation}
\verb|ActivationContext(type=|$type$, \verb|trace=|$[C_0, s_0, C_1, s_1, C_2]$\verb|)|
\end{quotation}
and represent the 100 AST subtrees that were activated most frequently during the execution. For each of these activation contexts, the heuristic attempts to construct a superinstruction candidate. Let us consider an example and choose the context $ctx$ which we define as follows:

\begin{verbatim}
ctx = ActivationContext(type=Long, trace=[LocalVariableWriteNode, 0,
                                          PrimitiveOperation:+, 0,
                                          LocalVariableReadNode])
\end{verbatim}


\section{Superinstructions}\label{sec:superinst}

\subsection{Increment Operation}

The superinstruction \sinst{increment} represents the increment of a local \textsf{Long} variable by a fixed integer.
In other words, the following subtree:


\end{document}